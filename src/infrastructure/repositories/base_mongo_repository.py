"""
Base MongoDB repository with common functionality.
Infrastructure layer - implements repository patterns for MongoDB.
"""
from abc import ABC, abstractmethod
from typing import Dict, Any, List, Optional, TypeVar, Generic
from motor.motor_asyncio import AsyncIOMotorDatabase, AsyncIOMotorCollection
from bson import ObjectId
from datetime import datetime
import logging

logger = logging.getLogger(__name__)

T = TypeVar('T')


class BaseMongoRepository(ABC, Generic[T]):
    """Base repository class for MongoDB operations."""
    
    def __init__(self, database: AsyncIOMotorDatabase, collection_name: str):
        self._database = database
        self._collection: AsyncIOMotorCollection = database[collection_name]
        self._collection_name = collection_name
    
    @abstractmethod
    def _to_entity(self, document: Dict[str, Any]) -> T:
        """Convert MongoDB document to domain entity."""
        pass
    
    @abstractmethod
    def _to_document(self, entity: T) -> Dict[str, Any]:
        """Convert domain entity to MongoDB document."""
        pass
    
    async def find_by_id(self, entity_id: str) -> Optional[T]:
        """Find entity by ID."""
        try:
            # Try as ObjectId first, then as string
            query = {"_id": ObjectId(entity_id)} if ObjectId.is_valid(entity_id) else {"id": entity_id}
            document = await self._collection.find_one(query)
            
            if document:
                return self._to_entity(document)
            return None
            
        except Exception as e:
            logger.error(f"Error finding document by ID {entity_id}: {e}")
            raise
    
    async def find_all(self, filter_dict: Optional[Dict[str, Any]] = None) -> List[T]:
        """Find all entities matching filter."""
        try:
            filter_dict = filter_dict or {}
            cursor = self._collection.find(filter_dict)
            documents = await cursor.to_list(length=None)
            
            return [self._to_entity(doc) for doc in documents]
            
        except Exception as e:
            logger.error(f"Error finding documents: {e}")
            raise
    
    async def find_one(self, filter_dict: Dict[str, Any]) -> Optional[T]:
        """Find single entity matching filter."""
        try:
            document = await self._collection.find_one(filter_dict)
            
            if document:
                return self._to_entity(document)
            return None
            
        except Exception as e:
            logger.error(f"Error finding document with filter {filter_dict}: {e}")
            raise
    
    async def insert_one(self, entity: T) -> T:
        """Insert a new entity."""
        try:
            document = self._to_document(entity)
            
            # Add timestamps if not present
            now = datetime.utcnow()
            if 'created_at' not in document:
                document['created_at'] = now
            if 'updated_at' not in document:
                document['updated_at'] = now
            
            result = await self._collection.insert_one(document)
            
            # Return the entity with the inserted ID if it was an ObjectId
            if hasattr(entity, 'id') and result.inserted_id:
                if isinstance(result.inserted_id, ObjectId):
                    # Update entity ID if it was generated by MongoDB
                    entity.id = str(result.inserted_id)
            
            logger.info(f"Inserted document with ID: {result.inserted_id}")
            return entity
            
        except Exception as e:
            logger.error(f"Error inserting document: {e}")
            raise
    
    async def update_one(self, entity: T) -> T:
        """Update an existing entity."""
        try:
            document = self._to_document(entity)
            entity_id = document.get('id') or document.get('_id')
            
            if not entity_id:
                raise ValueError("Entity must have an ID to update")
            
            # Add updated timestamp
            document['updated_at'] = datetime.utcnow()
            
            # Remove the ID from the update document to avoid conflicts
            update_doc = {k: v for k, v in document.items() if k not in ['_id', 'id']}
            
            # Try ObjectId first, then string ID
            query = {"_id": ObjectId(entity_id)} if ObjectId.is_valid(entity_id) else {"id": entity_id}
            
            result = await self._collection.update_one(
                query,
                {"$set": update_doc}
            )
            
            if result.matched_count == 0:
                raise ValueError(f"No document found with ID: {entity_id}")
            
            logger.info(f"Updated document with ID: {entity_id}")
            return entity
            
        except Exception as e:
            logger.error(f"Error updating document: {e}")
            raise
    
    async def delete_one(self, entity_id: str) -> bool:
        """Delete entity by ID."""
        try:
            # Try ObjectId first, then string ID
            query = {"_id": ObjectId(entity_id)} if ObjectId.is_valid(entity_id) else {"id": entity_id}
            
            result = await self._collection.delete_one(query)
            
            if result.deleted_count > 0:
                logger.info(f"Deleted document with ID: {entity_id}")
                return True
            else:
                logger.warning(f"No document found to delete with ID: {entity_id}")
                return False
                
        except Exception as e:
            logger.error(f"Error deleting document with ID {entity_id}: {e}")
            raise
    
    async def count(self, filter_dict: Optional[Dict[str, Any]] = None) -> int:
        """Count documents matching filter."""
        try:
            filter_dict = filter_dict or {}
            return await self._collection.count_documents(filter_dict)
        except Exception as e:
            logger.error(f"Error counting documents: {e}")
            raise
    
    def _convert_datetime_fields(self, document: Dict[str, Any], fields: List[str]) -> Dict[str, Any]:
        """Helper to convert datetime fields in documents."""
        for field in fields:
            if field in document and document[field]:
                if isinstance(document[field], str):
                    try:
                        document[field] = datetime.fromisoformat(document[field].replace('Z', '+00:00'))
                    except ValueError:
                        # Handle other datetime formats if needed
                        pass
        return document